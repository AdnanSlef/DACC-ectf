#!/usr/bin/env python3
"""
Description: Protects song by adding metadata, encryption, and integrity checks
Use: Once per song
"""
import json
import struct
import os
import wave
import hashlib
from argparse import ArgumentParser
import numpy as np


class Cipher(object):
    """Object to encrypt data"""
    
    def __init__(self, key):
        self.key = key
        #self.iv = randomness
        
    def encrypt(pt):
        """encrypt data
        Args:
            pt (bytes): the plaintext message to encrypt
        """
        speck = SpeckCipher(key,256,128,'CBC')
        #finish
    
    
def sha(): #currently just an example
    out = []
    sha2 = hashlib.sha256()
    sha2.update(b"Hello")
    out.append(sha2.hexdigest())
    sha2.update(b", world!")
    out.append(sha2.hexdigest())
    sha2_2 = hashlib.sha256()
    sha2_2.update(b'abc')
    out.append(sha2_2.hexdigest())
    return out


class ProtectedSong(object):
    """Example song object for protected song"""

    def __init__(self, path_to_song, metadata):
        """initialize values
        Args:
            path_to_song (string): file name where the song to be provisioned is stored
            metadata (bytearray): bytes containing metadata information
        """
        self.song = path_to_song
        self.full_song, self.original_song = self.read_song(path_to_song)
        self.metadata = metadata

    def save_secured_song_to_wave(self, file_location):
        """Saves secured song to wave file assuming all the same characteristics as original song
        Args:
            file_location (string): location to store the file including name"""
        protected_wav = wave.open(os.path.abspath(file_location), 'wb')
        protected_wav.setnchannels(self.original_song.getnchannels())
        protected_wav.setsampwidth(self.original_song.getsampwidth())
        protected_wav.setframerate(self.original_song.getframerate())
        protected_wav.writeframes(self.metadata)

        for val in self.full_song:
            protected_wav_val = struct.pack('<h', val)
            protected_wav.writeframesraw(protected_wav_val)

        protected_wav.close()

    def read_song(self, path, metadata_frames=0):
        """Reads a wave file
        Args:
            path (string): path to song
            metadata_frames (int): if not 0 disregard this number of frames as metadata
        Returns:
            vals (array): integer array of decoded values
            song (Wave Object): wave object associated with entered song
        """
        song = wave.open(os.path.abspath(path), 'r')
        if metadata_frames:
            song.readframes(metadata_frames)  # skip the metadata frames when assigning vals
        vals = np.frombuffer(song.readframes(song.getnframes()), dtype=np.int16)
        song.close()
        return vals, song


def create_metadata(regions, user, region_secrets, user_secrets):
    """Returns a byte string formatted as follows:
    METADATA_LENGTH(1B)/ownerID(1B)/REGION_LEN(1B)/USER_LEN(1B)/REGIONID1(1B)/REGIONID2 (1B)/.../opt. parity
    Args:
        regions (list): list of regions to provision song for
        user (string): user name for owner of the song
        region_secrets (dict): mapping of regions provided by region.secrets
        user_secrets (dict): mapping of users provided by user.secrets
    Returns:
        metadata (bytes): bytes of encoded metadata
    Example:
        >>create_metadata(['USA', 'Canada'], 'user1', {'USA': 1, 'Canada': 2}, {'user1': {'pin': '12345678', 'id': 0}})
        'x06/x00/x01/x00/x01/x02'
    """
    # note: metadata must be an even length since each sample is 2B long
    # and ARM processors require memory accesses to be aligned to the type size
    metadata = struct.pack(
        '=3B{regions_length}s{regions_len_2}s'.format(regions_length=len(regions), regions_len_2=len(regions) % 2),
        int(user_secrets[user]['id']), len(regions), 0,
        bytes([region_secrets[str(r)] for r in regions]),
        b'\x00' if len(regions) % 2 else b'')

    return bytes([len(metadata) + 1]) + metadata


def make_keys(keys_a, keys_b):
    """Combines key halves into whole keys"""
    keys = [keys_a['key'+str(i+1)+'a']+keys_b['key'+str(i+1)+'b']for i in range(len(keys_a))]
    return keys


def main():
    parser = ArgumentParser(description='main interface to protect songs')
    parser.add_argument('--region-list', nargs='+', help='List of regions song can be played in', required=True)
    parser.add_argument('--owner', help='Owner of song', required=True)
    parser.add_argument('--region-secrets-path', help='File location for the region secrets file', required=True)
    parser.add_argument('--user-secrets-path', help='File location for the user secrets file', required=True)
    parser.add_argument('--infile', help='Path to unprotected song', required=True)
    parser.add_argument('--outfile', help='Path to save the protected song', required=True)
    args = parser.parse_args()

    regions_json = json.load(open(os.path.abspath(args.region_secrets_path)))
    users_json = json.load(open(os.path.abspath(args.user_secrets_path)))
    
    region_secrets = regions_json['region_dict']
    user_secrets = users_json['user_dict']
    
    keys_a = users_json['keys_a']
    keys_b = regions_json['keys_b']
    key1, key2, key3 = make_keys(keys_a, keys_b)

    try:
        metadata = create_metadata(args.region_list, args.owner, region_secrets, user_secrets)
    except ValueError:
        raise ValueError('Ensure all user IDs are integers and all regions are in the provided region.secrets')
    protected_song = ProtectedSong(args.infile, metadata)
    protected_song.save_secured_song_to_wave(args.outfile)


if __name__ == '__main__':
    main()
